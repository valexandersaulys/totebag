{
    "contents" : "# TO-DO:\n# --> Enable other metrics than accuracy to be usedas measurements when doing ensembles\n\n# Needed libraries -> library(caret) for createDataPartition() function\n\n#' Create a new (empty) totebag object\n#'\n#' @param x matrix of features\n#' @param y vector of labels / response values\n#' @param type either \"regression\" or \"classification\", though the later is not supported at the moment\n#' @param wreplacement either True or False, reflects selecting models with replacement or not\n#' @param sorted.initialization a number that defines building an initial ensemble with the strongest initial models\n#' @param bagged.selection the number of times to use bagged selection in model selection\n#' @param hillclimb.ratio the number\n#' @param p percentage of models to use during bagged selection\n#' \nnew.totebag <- function (x, y,\n                         type=\"regression\",\n                         with.replacement=TRUE,\n                         sorted.initialization=0,\n                         bagged.selection=20,\n                         hillclimb.ratio=0.4,\n                         p=0.5 ) {\n  x = as.matrix(x);\n  type = \"regression\";\n  \n  data <- list(x=object$x, y=object$y);\n  \n  dataPartition <- createDataPartition(data, p=object$hillcimb.ratio, list = FALSE)[, 1];\n  training <- data[dataPartition, ];\n  hillclimb <- data[-dataPartition, ];\n  \n  object <- list(\n    x=x,                 # Full X data\n    y=y,                 # Full Y data\n    type=type,\n    with.replacement=with.replacement,\n    sorted.initialization=sorted.initialization,\n    bagged.selection=bagged.selection,\n    hillclimb=hillclimb,\n    p=p,                 # percentage of models list to use during Bagged Ensemble Selection\n    k=k,                 # the number of times to do Bagged Ensemble Selection\n    # Lists of added-parts\n    training=training,   # to make sure all models are trained on the same models\n    hillclimb=hillclimb, # to make sure all models are validated on the same validation data\n    models=list(),       # holds the library of models\n    model.args=list(),   # their corresponding model params\n    y.preds=list(),      # the predicted y values on hillclimb\n    asm=list()           # their corresponding accuracy scores\n  );\n  \n  class(object) <- 'totebag';\n  \n  return(object);\n}\n\n#' Adds new model to the totebag ensemble\n#' @param object the totebag object to be operated on\n#' @param model model fitting the given data\n#' @param train.params params during training\n#' @param pred.params params during predicting\n#' @param formula gives the formula to be used during training\nadd.totebag <- function(object,model,train.params,pred.params,formula) {\n  if (!is.null(formula)) {    # Currently to be implemented\n    # First we define a variable to represent the length of our R models\n    to.be.added <- length(object$models) + 1;\n    \n    # Then we add the model to the list of models to be utilized\n    object$models[[to.be.added]] <- model;\n    object$model.args[[to.be.added]] <- train.params;\n    object$model.pred.args[[to.be.added]] <- pred.params;\n    \n    # Train the model\n    # Make predictions on the hillclimb ratio\n    # Put those prediction percentages into asm\n    \n    command <- as.character(model) \n    current.model <- do.call(command,c(object$training,train.params))\n    \n    command <- as.character(model) + \".predict\"\n    current.predictions <- do.call(command, c(object$hillcimb))\n    \n    object$y.preds <- current.predictions\n    if (type=='classification') {\n      object$asm <- confusionMatrix(data=current.predictions,reference=hillclimb)$overall\n    } else {# if (type==\"regression\") {  # Defaults to regression\n      object$asm <- (1 - mean(error.totebag(current.predictions,hillclimb)))\n    } \n  } else {    # We have a formula to pass instead of an X and Y value\n    # First we define a variable to represent the length of our R models\n    to.be.added <- length(object$models) + 1;\n    \n    # Then we add the model to the list of models to be utilized\n    object$models[[to.be.added]] <- model;\n    object$model.args[[to.be.added]] <- train.params;\n    object$model.pred.args[[to.be.added]] <- preds.params;\n    \n    # Train the model\n    # Make predictions on the hillclimb ratio\n    # Put those prediction percentages into asm\n     \n    current.model <- do.call(as.character(model),c(formula,data=object$training,train.params))\n    current.predictions <- do.call(command, c(formula,newdata=object$hillcimb,pred.params))\n    \n    object$y.preds <- current.predictions\n    if (type=='classification') {\n      object$asm <- confusionMatrix(data=current.predictions,reference=hillclimb)$overall\n    } else {# if (type==\"regression\") {  # Defaults to regression\n      object$asm <- (1 - mean(error.totebag(current.predictions,hillclimb)))\n    } \n  } \n}\n\n#' Predicts newdata with totebag ensemble model\n#'\n#' @param newdata our new data\n#' @param percentage the % of models to use\npredict.totebag <- function(object,\n                            newdata,\n                            percentage\n                            ) {\n  if (object$bagged.selection==TRUE) {\n    bagged.pred.totebag(object,newdata,percentage);\n  } else {\n    nonbagged.pred.totebag(object,newdata,percentage);\n  }\n  \n}\n\n#' Only meant for internal package use. Totebag prediction with Bagged Selection\n#' @param object\n#' @param newdata\n#' @param percentage\nbagged.pred.totebag <- function(object, newdata, percentage) {\n   \n  for (i in 1:object$k) {\n      best.model <- list()\n      newdata <- as.matrix(newdata);\n          \n      # Bagged Ensemble Selection:\n      # sample(x,size) will randomly create vectors for sampling\n      # where x is an integer and sampling takes place from 1 to x, size is the size of the list it returns\n      positions <- sample(nrow(object$models),object$p * nrow(object$models))\n            \n      if (object$sorted.initialization > 1) {     # This needs to be fleshed out\n         n <- length(object$asm);\n         g <- object$sorted.initialization - 1;\n         sort(object$asm,partial=n-g)[n-g];    # This returns the next highest value\n      } else {\n         g <- which.max(object$asm[positions,]);\n         best.models[[0]] <- object$models[[g]];\n         ACC <- object$asm[[g]] # Stores accuracy so far\n         mlocs[[0]] <- g;    # Stores locations of the models being used\n      }\n        \n        \n      while (length(best.models) < (percentage * object$models)) {\n          # Loop through and compare\n          for (i in 1:length(object$models[positions,])) {\n              temp.locs <- c(mlocs,i);\n              if (object$type=='classification') { temp.acc = clas.pred.totebag(object,temp.locs); }\n              else { temp.acc = reg.pred.totebag(object,temp.locs); }  # else, its a regression\n\n              if (temp.acc > ACC) { mlocs = temp.locs; ACC = temp.acc; } # if its better, replace!\n        }\n      }\n  }\n\n}\n\n#' Only meant for internal package use. Totebag prediction without bagged selection.\n#' @param object\n#' @param newdata\n#' @param percentage\nnonbagged.pred.totebag <- function(object,newdata,percentage) {\n  best.model <- list()\n  newdata <- as.matrix(newdata);\n  \n  if (object$sorted.initialization > 1) {     # This needs to be fleshed out\n    n <- length(object$asm);\n    g <- object$sorted.initialization - 1;\n    sort(object$asm,partial=n-g)[n-g];    # This returns the next highest value\n  }\n  else {\n    g <- which.max(object$asm);\n    best.models[[0]] <- object$models[[g]];\n    ACC <- object$asm[[g]] # Stores accuracy so far\n    mlocs[[0]] <- g;    # Stores locations of the models being used\n  }\n  \n  \n  while (length(best.models) < (percentage * object$models)) {\n    # Loop through and compare\n    for (i in 1:length(object$models)) {\n      temp.locs <- c(mlocs,i);\n      if (object$type=='classification') { temp.acc = clas.pred.totebag(object,temp.locs); }\n      else { temp.acc = reg.pred.totebag(object,temp.locs); }\n      \n      if (temp.acc > ACC) { mlocs = temp.locs; ACC = temp.acc; } # if its better, replace!\n    }\n  }\n}\n\n#' Only meant for internal package use. Regression prediction in totebag.\n#' @param l.locs list of locations of the models in the object\n#' @param object totebag object\nreg.pred.totebag <- function(object, l.locs) {\n  \n  # declare temp.preds as a matrix of m x n (NA values)\n  # where m is the length l.locs\n  # and n is the length of hillclimb\n  temp <- matrix(data=NA,nrow=length(object$hillclimb),ncol=length(l.locs))\n  \n  for (i in 1:length(l.locs)) { \n    # each location list of y.preds is given column i in temp.preds\n    temp[[i]] <- object$y.preds[[ l.locs[i] ]]\n  }\n  # take the average of the rows and put into a separate list of values\n  temp.preds <- rowMeans(temp)\n  # measure the error with the below function\n  temp.error <- error.totebag(temp.preds,object$hillclimb)\n  # return 1 - average error rate --> accuracy rate\n  return(1 - colMeans(temp.error))    # check during debugging that this is one value\n}\n\n#' Only meant for internal package use. Private function for finding error.\n#' @param true.vals list of true values\n#' @param pred.vals list of predicted values\nerror.totebag <- function(pred.vals,true.vals) {\n  error <- sqrt(sum((true.vals - pred.vals)^2))\n  return(error)\n}\n",
    "created" : 1424824418541.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2289928748",
    "id" : "4FC27894",
    "lastKnownWriteTime" : 1424828136,
    "path" : "~/workspace/R/Packages/totebag/R/totebag.R",
    "project_path" : "R/totebag.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}